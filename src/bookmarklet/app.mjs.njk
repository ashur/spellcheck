/* {% from "system/loader.njk" import partial %} */
import Grid from "./grid.mjs";
import Storage from "./storage.mjs";
import TLL from "./tll.mjs";
import UI from "./ui.mjs";

export const APP_VERSION = "{{ pkg.version }}";

export default class App
{
	/**
	 * @param {Object} options
	 * @param {Grid} [options.grid
	 * @param {Object} options.storage
	 * @param {TLL} options.tll
	 */
	constructor({ grid, storage, tll } = {})
	{
		this.grid = grid;
		this.storage = storage;
		this.tll = tll;
	}

	/**
	 * @param {string} hintsUrl
	 * @param {string} date - ex., "2022-06-05"
	 * @return {Object}
	 * @throws Will throw an error if hints cannot be parsed from the given URL
	 */
	static async fetchHints( hintsUrl, date )
	{
		const hints = {};

		const response = await fetch( hintsUrl );
		const div = document.createElement( "html" );
		div.innerHTML = await response.text();

		/*
		 * Grid
		 */
		const gridElement = div.querySelector( "[name='articleBody'] .StoryBodyCompanionColumn:nth-of-type(3) p:nth-of-type(4)" );
		if( gridElement )
		{
			hints.grid = Grid.getInstance({
				date,
				gridText: gridElement.innerText,
			});
		}
		else
		{
			throw new Error( "Could not locate grid element on hints page" );
		}

		/*
		 * Two-Letter List
		 */
		const tllElement = div.querySelector( "[name='articleBody'] .StoryBodyCompanionColumn:nth-of-type(5) div p:nth-child(2)" );
		if( tllElement )
		{
			hints.tll = TLL.getInstance({
				date,
				tllText: tllElement.innerText,
			});
		}
		else
		{
			throw new Error( "Could not locate two-letter list element on hints page" );
		}

		return hints;
	}

	/**
	 * Return a new instance of App populated with today's grid. Called the
	 * first time the bookmarklet is invoked after page load.
	 *
	 * @param {string} hintsUrl
	 * @param {Storage} [storageSource]
	 * @return {App}
	 */
	static async getInstance( hintsUrl, storageSource )
	{
		const {pathname: urlPathname} = new URL( hintsUrl );
		const date = urlPathname
			.split( "/" )
			.slice( 1, 4 )
			.join( "-" );

		/*
		 * Storage
		 *
		 * If the version in storage doesn't match the current version let's
		 * go ahead and refetch hints, in case the data structure has changed.
		 */
		const storage = new Storage(
			storageSource || window.localStorage,
			APP_VERSION,
		);

		let shouldFetchHints = APP_VERSION !== storage.getItem( "version" );

		let grid, tll;
		if( !shouldFetchHints )
		{
			/*
			 * Grid
			 *
			 * Use grid from localStorage if today's grid has already been parsed
			 * and stored.
			 */
			const gridData = storage.getItem( "grid" );
			try
			{
				grid = Grid.getInstance( gridData );

				shouldFetchHints = shouldFetchHints
					|| grid.date !== date;
			}
			catch( error )
			{
				// If instantiation fails for any reason — ex., missing required
				// properties — fetch today's data and start over.
				shouldFetchHints = true;
			}
		}

		if( !shouldFetchHints )
		{
			/*
			 * Two-Letter List
			 *
			 * Use TLL from localStorage if today's TLL has already been parsed
			 * and stored.
			 */
			const tllData = storage.getItem( "tll" );
			try
			{
				tll = TLL.getInstance( tllData );

				shouldFetchHints = shouldFetchHints
					|| tll.date !== date;
			}
			catch( error )
			{
				// If instantiation fails for any reason — ex., missing required
				// properties — fetch today's data and start over.
				shouldFetchHints = true;
			}
		}

		/*
		 * Fetch remote hints
		 *
		 * If app data isn't defined locally or is out of date, fetch and parse
		 * today's hints, and then store them.
		 */
		if( shouldFetchHints )
		{
			// console.log( `Fetching remote hints for '${date}'...` );

			const {grid: latestGrid, tll: latestTLL} = await App.fetchHints( hintsUrl, date );

			grid = latestGrid;
			tll = latestTLL;

			storage.setItem( "grid", grid );
			storage.setItem( "tll", tll );
		}
		else
		{
			// console.log( `Using hints from storage for '${date}'` );
		}

		return new App({
			grid: grid,
			storage,
			tll: tll,
		});
	}

	/**
	 * @param {string} message
	 * @param {string} [details] - ex., .message from a thrown Error
	 */
	static showErrorModal( message, details )
	{
		UI.showModal({
			context: {
				error: {
					details: details,
					message: message,
				},
			},
			name: "error",
			subtitle: "An unexpected problem occurred.",
			template: "error",
		});
	}

	/**
	 * Shim for bookmarklet
	 */
	showGridModal()
	{
		return this.showMainModal();
	}

	/**
	 * Show the main Spell Check modal
	 */
	showMainModal()
	{
		const {words=[]} = this.storage.getUnscopedData( "sb-today" ) || {};

		UI.showModal({
			context: {
				grid: this.grid,
				tll: this.tll,
				words,
			},
			name: "main",
			template: "main",
		});

		/*
		 * Carousel dots
		 */
		const carouselCards = document.querySelector( ".spellcheck-carousel__cards" );
		if( carouselCards && carouselCards.childElementCount > 1 )
		{
			carouselCards.addEventListener( "scroll", (event) =>
			{
				const cardIndex = Math.round(
					event.target.scrollLeft /
					event.target.scrollWidth *
					carouselCards.childElementCount
				);

				document.querySelectorAll( ".spellcheck-carousel__dot" ).forEach( (dotElement, dotIndex) =>
				{
					if( dotIndex === cardIndex )
					{
						dotElement.dataset.active = "true";
					}
					else
					{
						dotElement.dataset.active = "false";
					}
				});
			});
			carouselCards.style.setProperty( "--carousel-columns", carouselCards.childElementCount );

			const carouselDots = document.querySelector( ".spellcheck-carousel__dots" );
			document.querySelectorAll( ".spellcheck-carousel__cards > *" ).forEach( (carouselCard, index) =>
			{
				const carouselDot = document.createElement( "div" );
				carouselDot.classList.add( "spellcheck-carousel__dot" );
				if( index === 0 )
				{
					carouselDot.dataset.active = "true";
				}
				carouselDots.appendChild( carouselDot );
			});
		}
	}
}
